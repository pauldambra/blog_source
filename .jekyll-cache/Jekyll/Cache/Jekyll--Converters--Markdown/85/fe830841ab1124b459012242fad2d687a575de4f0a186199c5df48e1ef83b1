I"RÅ<p>We had a brief conversation at work the other day about extending a type to make our code clearer‚Ä¶</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">MeaningfulName</span> <span class="p">:</span> <span class="n">MathsName</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="nf">MeaningfulName</span><span class="p">(</span><span class="kt">double</span> <span class="n">w</span><span class="p">,</span> <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">,</span> <span class="kt">double</span> <span class="n">z</span><span class="p">)</span> <span class="p">:</span> <span class="k">base</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<!--more-->
<!--alex ignore easy --->
<p>We're porting some code written by our maths wizards and there's lots of convention in their domain specific language which we were trying to capture (because we're not maths wizards and (maybe only I) get easily lost).</p>

<p>In one case the prospective base class wasn't a class but a struct so we couldn't do this. And we briefly discussed whether we should convert it to a class.</p>

<p>In that conversation I stated that structs weren't value objects. You see, I've checked in the past. After a job interview where I stated that they were value objects and wrote some tests afterwards to check‚Ä¶ I wish I still had those tests because‚Ä¶</p>

<p>Luckily, I have colleagues whose opinions I trust and I try for my opinions to be 'strong opinions weakly held' (which might be a Greg Young-ism). So while I'm having a lazy day I wrote some tests and blew my mind!</p>

<h2 id="tldr">TLDR;</h2>

<ul>
  <li>Don't trust my memory</li>
  <li>Do test your assumptions! Do test your code! Maybe use structs!</li>
  <li>Clear names are likely to be much more important than C# performance.</li>
</ul>

<h2 id="a-struct---what-is-it"><a href="http://www.youtube.com/watch?v=TxWN8AhNER0">A struct - What is it?</a></h2>

<h4 id="value-semantics">Value Semantics</h4>

<p><a href="https://msdn.microsoft.com/en-gb/library/aa664472(v=vs.71).aspx">Quoting from MSDN</a> "A variable of a struct type directly contains the data of the struct, whereas a variable of a class type contains a reference to the data, the latter known as an object."</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">public</span> <span class="k">class</span> <span class="nc">NotValueSemantics</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="kt">int</span> <span class="n">X</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

	<span class="k">public</span> <span class="nf">NotValueSemantics</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> 
	<span class="p">{</span>
		<span class="n">X</span> <span class="p">=</span> <span class="n">x</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">var</span> <span class="n">first</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">NotValueSemantics</span><span class="p">(</span><span class="m">10</span><span class="p">);</span>
<span class="kt">var</span> <span class="n">second</span> <span class="p">=</span> <span class="n">first</span><span class="p">;</span>
<span class="n">second</span><span class="p">.</span><span class="n">X</span> <span class="p">=</span> <span class="m">100</span><span class="p">;</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">first</span><span class="p">.</span><span class="n">X</span><span class="p">);</span> <span class="c1">//writes 100</span>

</code></pre></div></div>

<p>in the example above the line <code class="language-plaintext highlighter-rouge">var second = first</code> adds another reference to the memory that holds the <code class="language-plaintext highlighter-rouge">first</code> Object so operations on <code class="language-plaintext highlighter-rouge">second</code> affect <code class="language-plaintext highlighter-rouge">first</code>. The assignment of 100 to <code class="language-plaintext highlighter-rouge">second.X</code> is reflected in <code class="language-plaintext highlighter-rouge">first.X</code>.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">public</span> <span class="k">struct</span> <span class="nc">ValueSemantics</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="kt">int</span> <span class="n">X</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

	<span class="k">public</span> <span class="nf">ValueSemantics</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">:</span> <span class="k">this</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">X</span> <span class="p">=</span> <span class="n">x</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">var</span> <span class="n">first</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ValueSemantics</span><span class="p">(</span><span class="m">10</span><span class="p">);</span>
<span class="kt">var</span> <span class="n">second</span> <span class="p">=</span> <span class="n">first</span><span class="p">;</span>
<span class="n">second</span><span class="p">.</span><span class="n">X</span> <span class="p">=</span> <span class="m">100</span><span class="p">;</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">first</span><span class="p">.</span><span class="n">X</span><span class="p">);</span> <span class="c1">//writes *10*</span>

</code></pre></div></div>

<p>Instead if we declare it as a struct (other than requiring a call through to the base parameterless constructor) the difference is that <code class="language-plaintext highlighter-rouge">var second = first</code> copies the data not a reference to it. As a result operations on <code class="language-plaintext highlighter-rouge">second</code> don't affect <code class="language-plaintext highlighter-rouge">first</code> so the assignment <code class="language-plaintext highlighter-rouge">second.X = 100;</code> is not reflected in <code class="language-plaintext highlighter-rouge">first.X</code>.</p>

<p>As an aside, it is possible to "break" this difference and <a href="http://jonskeet.uk/csharp/parameters.html">this excellent article by Jon Skeet</a> shows how.</p>

<h4 id="value-object">Value Object</h4>

<p>The key fact about a <a href="http://martinfowler.com/bliki/ValueObject.html">value object</a> is that its properties determine <em>what it is</em>, so two value objects are equal when their properties are equal. Eric Evans in <a href="http://www.amazon.co.uk/Domain-driven-Design-Tackling-Complexity-Software/dp/0321125215">Domain-driven Design: Tackling Complexity in the Heart of Software</a> says "you don't care which '4' you have or which 'Q'".</p>

<p>So here are the tests I wrote to check my understanding of structs‚Ä¶</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">Test</span><span class="p">]</span> <span class="c1">//this test passes!</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">structs_with_equal_properties_are_equal</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">a</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ValueObject</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">);</span>
    <span class="kt">var</span> <span class="n">b</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ValueObject</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">);</span>
    <span class="n">Assert</span><span class="p">.</span><span class="nf">AreEqual</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">[</span><span class="n">Test</span><span class="p">]</span> <span class="c1">//this test passes!</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">structs_with_different_properties_are_not_equal</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">a</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ValueObject</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">);</span>
    <span class="kt">var</span> <span class="n">b</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ValueObject</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">);</span>
    <span class="n">Assert</span><span class="p">.</span><span class="nf">AreNotEqual</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">struct</span> <span class="nc">ValueObject</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">X</span> <span class="p">{</span><span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;}</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Y</span> <span class="p">{</span><span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;}</span>

    <span class="k">public</span> <span class="nf">ValueObject</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
        <span class="p">:</span> <span class="k">this</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">X</span> <span class="p">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="n">Y</span> <span class="p">=</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Both of those tests pass. I'd have confidently put money on those tests failing. As above I'm certain I've written similar tests in the past and seen them fail - I should trust my memory even less than I currently do!</p>

<p>So a struct in C# appears to be a pretty cheap way (in terms of typing) to define a value object.</p>

<p>The equivalent‚Ä¶ i.e. a class which acts as a value object.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">ValueObject</span> <span class="p">:</span> <span class="n">IEquatable</span><span class="p">&lt;</span><span class="n">ValueObject</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">X</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Y</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="nf">ValueObject</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">X</span> <span class="p">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="n">Y</span> <span class="p">=</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="kt">bool</span> <span class="nf">Equals</span><span class="p">(</span><span class="n">ValueObject</span> <span class="n">other</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nf">ReferenceEquals</span><span class="p">(</span><span class="k">null</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span> <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nf">ReferenceEquals</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span> <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">X</span> <span class="p">==</span> <span class="n">other</span><span class="p">.</span><span class="n">X</span> <span class="p">&amp;&amp;</span> <span class="n">Y</span> <span class="p">==</span> <span class="n">other</span><span class="p">.</span><span class="n">Y</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">override</span> <span class="kt">bool</span> <span class="nf">Equals</span><span class="p">(</span><span class="kt">object</span> <span class="n">obj</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nf">ReferenceEquals</span><span class="p">(</span><span class="k">null</span><span class="p">,</span> <span class="n">obj</span><span class="p">))</span> <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nf">ReferenceEquals</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">obj</span><span class="p">))</span> <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="nf">GetType</span><span class="p">()</span> <span class="p">!=</span> <span class="k">this</span><span class="p">.</span><span class="nf">GetType</span><span class="p">())</span> <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
        <span class="k">return</span> <span class="nf">Equals</span><span class="p">((</span><span class="n">ValueObject</span><span class="p">)</span> <span class="n">obj</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">override</span> <span class="kt">int</span> <span class="nf">GetHashCode</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">unchecked</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">X</span><span class="p">*</span><span class="m">397</span><span class="p">)</span> <span class="p">^</span> <span class="n">Y</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="k">operator</span> <span class="p">==(</span><span class="n">ValueObject</span> <span class="n">left</span><span class="p">,</span> <span class="n">ValueObject</span> <span class="n">right</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nf">Equals</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="k">operator</span> <span class="p">!=(</span><span class="n">ValueObject</span> <span class="n">left</span><span class="p">,</span> <span class="n">ValueObject</span> <span class="n">right</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="p">!</span><span class="nf">Equals</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Much more code to read than the equivalent struct! Although I used resharper's code generation to add the equality methods so actually not that much more of the typing.</p>

<p>The <a href="https://msdn.microsoft.com/en-us/library/aa664471(v=vs.71).aspx">section on differences between structs and classes on MSDN</a> is unusually clear for MS documentation and worth a read.</p>

<h2 id="so">So‚Ä¶</h2>
<p>I've learned something and that has value. However, the team still has the problem of wanting to improve clarity. What solutions might there be.</p>

<p>I can think of three.</p>

<h4 id="1-dont-do-anything">1) Don't do anything</h4>

<p>Maybe leave it as structs and use variable names and some method &amp; class extractiion refactorings to make what is happening clearer instead of leaning on the types to do that.</p>

<p>This would be fine. My feeling is that the code in question leads itself to errors because it has multiple things with the same type but different semantics being used close together. It feels like it will be easier to introduce bugs as it is - but we should always be careful so this is an option.</p>

<h4 id="2-use-a-wrapper-class">2) Use a wrapper class</h4>

<p>This can be a really useful way of extending a sealed object or struct.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">MeaningfulName</span> 
<span class="p">{</span>
	<span class="k">private</span> <span class="n">MathsName</span> <span class="n">_mathsThing</span><span class="p">;</span>

	<span class="k">public</span> <span class="nf">MeaningfulName</span><span class="p">(</span><span class="kt">double</span> <span class="n">w</span><span class="p">,</span> <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">,</span> <span class="kt">double</span> <span class="n">z</span> <span class="p">)</span>	
	<span class="p">{</span>
		<span class="n">_mathsThing</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">MathsName</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="kt">double</span> <span class="nf">DoAMathsThing</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">)</span> 
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">_mathsThing</span><span class="p">.</span><span class="nf">DoAMathsThing</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If there was a requirement to extend the functionality of <code class="language-plaintext highlighter-rouge">MathsName</code> and we didn't own that object then this would be a good solution but this wrapper would be calling the wrapped method with no alterations. And <code class="language-plaintext highlighter-rouge">MathsName</code> has a lot of methods :(</p>

<p>So lots of the typing to implement but even more importantly it's possible that someone can alter <code class="language-plaintext highlighter-rouge">MathsName</code> without realising that they need to alter <code class="language-plaintext highlighter-rouge">MeaningfulName</code> too so there's the potential for bugs. It's better to help people fall into the pit of success and this solution doesn't do that.</p>

<h4 id="3-change-it-to-a-class">3) Change it to a class</h4>

<p>There'd not be very much of the typing. Only the addition of the equality methods (and probably some equality tests for safety). The struct in question is relatively well covered anyway so the change would be safe.</p>

<p>But we create tens of thousands of these structs and pass them around. What would the impact of converting this to a class <em>be</em>.
<!--alex ignore fight --->
Class vs. Struct - the big fight
‚Äî‚Äî‚Äî-</p>

<p>I created a console application that creates a bunch of objects and structs and then calls a method on them. You can <a href="https://gist.github.com/pauldambra/e3fb07f73e151152fa3c">see the full program here</a>.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">ValueClass</span> <span class="p">:</span> <span class="n">IEquatable</span><span class="p">&lt;</span><span class="n">ValueClass</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">double</span> <span class="n">Z</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">double</span> <span class="n">Y</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">double</span> <span class="n">X</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">double</span> <span class="n">W</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="nf">ValueClass</span><span class="p">(</span><span class="kt">double</span> <span class="n">w</span><span class="p">,</span> <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">,</span> <span class="kt">double</span> <span class="n">z</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">W</span> <span class="p">=</span> <span class="n">w</span><span class="p">;</span> <span class="n">X</span> <span class="p">=</span> <span class="n">x</span><span class="p">;</span> <span class="n">Y</span> <span class="p">=</span> <span class="n">y</span><span class="p">;</span> <span class="n">Z</span> <span class="p">=</span> <span class="n">z</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">ValueClass</span> <span class="k">operator</span> <span class="p">+(</span><span class="n">ValueClass</span> <span class="n">left</span><span class="p">,</span> <span class="n">ValueClass</span> <span class="n">right</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">ValueClass</span><span class="p">(</span><span class="n">left</span><span class="p">.</span><span class="n">W</span> <span class="p">+</span> <span class="n">right</span><span class="p">.</span><span class="n">W</span><span class="p">,</span> <span class="n">left</span><span class="p">.</span><span class="n">X</span> <span class="p">+</span> <span class="n">right</span><span class="p">.</span><span class="n">X</span><span class="p">,</span> <span class="n">left</span><span class="p">.</span><span class="n">Y</span> <span class="p">+</span> <span class="n">right</span><span class="p">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">left</span><span class="p">.</span><span class="n">Z</span> <span class="p">+</span> <span class="n">right</span><span class="p">.</span><span class="n">Z</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">//snip equality members</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">struct</span> <span class="nc">ValueStruct</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">double</span> <span class="n">Z</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">double</span> <span class="n">Y</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">double</span> <span class="n">X</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">double</span> <span class="n">W</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="nf">ValueStruct</span><span class="p">(</span><span class="kt">double</span> <span class="n">w</span><span class="p">,</span> <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">,</span> <span class="kt">double</span> <span class="n">z</span><span class="p">)</span> <span class="p">:</span> <span class="k">this</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">W</span> <span class="p">=</span> <span class="n">w</span><span class="p">;</span> <span class="n">X</span> <span class="p">=</span> <span class="n">x</span><span class="p">;</span> <span class="n">Y</span> <span class="p">=</span> <span class="n">y</span><span class="p">;</span> <span class="n">Z</span> <span class="p">=</span> <span class="n">z</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">ValueStruct</span> <span class="k">operator</span> <span class="p">+(</span><span class="n">ValueStruct</span> <span class="n">left</span><span class="p">,</span> <span class="n">ValueStruct</span> <span class="n">right</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">ValueStruct</span><span class="p">(</span><span class="n">left</span><span class="p">.</span><span class="n">W</span> <span class="p">+</span> <span class="n">right</span><span class="p">.</span><span class="n">W</span><span class="p">,</span> <span class="n">left</span><span class="p">.</span><span class="n">X</span> <span class="p">+</span> <span class="n">right</span><span class="p">.</span><span class="n">X</span><span class="p">,</span> <span class="n">left</span><span class="p">.</span><span class="n">Y</span> <span class="p">+</span> <span class="n">right</span><span class="p">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">left</span><span class="p">.</span><span class="n">Z</span> <span class="p">+</span> <span class="n">right</span><span class="p">.</span><span class="n">Z</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>and then doing something like</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">AddObjectsTogether</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">endValues</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ValueClass</span><span class="p">&gt;(</span><span class="n">Capacity</span><span class="p">);</span>

    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="k">value</span> <span class="k">in</span> <span class="nf">CreateABunchOfObjects</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">endValues</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="k">value</span> <span class="p">+</span> <span class="nf">MakeRandomValueClass</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="profiling">Profiling</h4>

<p>First I profiled the application running with a <code class="language-plaintext highlighter-rouge">Capacity</code> of 25 million. The code spent a little less than 10% of its time dealing with the structs and a little more than 12% of its time dealing with classes. Running with a capacity of 250,000 showed the reverse.</p>

<p>What this told me was I don't really understand profiling‚Ä¶ Doh!</p>

<p><em>And</em> you can create <em>seventy five million</em> structs in 2.8 seconds and <em>seventy five million</em> object in 2.3 seconds. That's orders of magnitude higher than I care about.</p>

<h4 id="memory">Memory</h4>

<p>When running the program to generate the structs it ran for about five seconds, preallocated around 790MB memory and kept that amount of memory in use until the end
<img src="/images/structs.png" alt="just generating structs" class="img-responsive center-block" /></p>

<p>When running the program to generate objects it ran for about <em>thirty</em> seconds, used slightly more memory, but didn't preallocate the memory.
<img src="/images/objects.png" alt="just generating classes" class="img-responsive center-block" /></p>

<p>When running the program to generate both it ran for about <em>thirty</em> seconds, used slightly more memory, but didn't preallocate the memory.
<img src="/images/both.png" alt="just generating classes" class="img-responsive center-block" /></p>

<p>What this told me was I've no idea about memory profiling‚Ä¶ Doh!</p>

<p>But that there's some tradeoff to be made where if you are creating primarily structs the compiler can preallocate memory to speed things up but if you aren't then it cannot - maybe?! That needs some research‚Ä¶</p>

<h2 id="performance">Performance</h2>

<p>I definitely need to learn how to profile programs.</p>

<p>The speed-up when dealing <em>primarily</em> with structs is intriguing but:</p>

<ul>
  <li>it came with more constant memory usage - easier to budget for but possible requires more overall</li>
  <li>I don't think the real code that led to this is primarily structs so this might be a red herring</li>
</ul>

<h2 id="overall">Overall</h2>

<p>A much longer and more rambling post than anyone deserved to read!</p>

<p>Do test your assumptions! Do test your code! Maybe use structs!</p>

:ET