I"à5<p>At the end of the last post I realised I'd sacrificed some good practice in the rush to make it work (i.e. worked normally like all those other guilty software engineers everywhere everyday.)
<!--alex ignore kids --->
So earlier today I played with the kids to tire them out enough that I could distract them with television and write some #holidaycode because I am a good(-ish) parent.</p>

<p>I managed to</p>

<ul>
  <li>switch from using magic strings in the messagebus channel and topic identifiers</li>
  <li>remove some duplication</li>
  <li>and get some tests around ReactJS</li>
</ul>

<!--more-->

<h1 id="messagebus-channels-and-topics">Messagebus channels and topics</h1>

<p>In the last post we (I) used magic strings to identify the channel and topic that messages were being published to.</p>

<p>I'm not completely sold on this particular structure:</p>

<pre><code class="language-JS">var messageBusStructure = {
	channels: {
		filters: 'filters'
	},
	topics: {
		filters: {
			yearBoundsChange: 'year.bounds.change'
		}
	}
};
</code></pre>

<p>but the general idea holds since it should mean that the postal publish/subscribe code is less prone to typing errors.</p>

<pre><code class="language-JS">postal.subscribe({
	channel: bus.channels.filters,
	topic : bus.topics.filters.yearBoundsChange,
	callback: function(d, e) {
		this.filterData(d);
	}
}).context(this);

//is better than

postal.subscribe({
	channel: "filters",
	topic : "year.bounds.change",
	callback: function(d, e) {
    	this.filterData(d);
  	}
}).context(this);
</code></pre>

<h1 id="remove-duplication-with-fire">Remove duplication with fire</h1>

<p>Then I componentised (ugh, is that a word?!) the input controls being used in the FilterBox so I could remove the duplication of handling their events.</p>

<pre><code class="language-JS">var YearFilterInput = React.createClass({
	publishOnChange: function(event) {
		var eventData = {};
		eventData[this.props.name.toLowerCase()] = 
			parseInt(event.target.value, 10);

		postal.publish({
			channel: bus.channels.filters,
			topic : bus.topics.filters.yearBoundsChange,
			data: eventData
		});
	},
	render: function() {
		return (
				&lt;div className="form-group"&gt;
					&lt;label htmlFor={this.props.name}&gt;{this.props.name}&lt;/label&gt;
					&lt;input type="number" 
						   name={this.props.name}
						   className="form-control"
						   defaultValue={this.props.default}
						   min={this.props.initialEarliest} 
						   max={this.props.initialLatest}
						   onChange={this.publishOnChange}/&gt;
				&lt;/div&gt;
		);
	}
});

var FilterBox = React.createClass({
	render: function() {
		return (
			&lt;div className="col-xs-12"&gt;
				&lt;YearFilterInput name="Earliest" 
								 default={this.props.initialEarliest}
								 initialEarliest={this.props.initialEarliest}
								 initialLatest={this.props.initialLatest} /&gt;
				&lt;YearFilterInput name="Latest" 
								 default={this.props.initialLatest}
								 initialEarliest={this.props.initialEarliest}
								 initialLatest={this.props.initialLatest} /&gt;
			&lt;/div&gt;
		);
	}
});
</code></pre>

<p>This changed the structure of the data that forms the message.</p>

<pre><code class="language-JS">publishOnChange: function(event) {
	var eventData = {};
	eventData[this.props.name.toLowerCase()] = 
		parseInt(event.target.value, 10);

	postal.publish({
		channel: bus.channels.filters,
		topic : bus.topics.filters.yearBoundsChange,
		data: eventData
	});
}
</code></pre>

<p>Now, since the component only knows about itself, the eventdata is an object with this component's identifier as a property and the new integer value of the input control as the value for the property.</p>

<p>I didn't want to read both Year filter values in order to send the (currently) two filter inputs as the last version of the code did. There's little point it being a component if it has to know about other components on the page to work.</p>

<p>That does mean that the <code class="language-plaintext highlighter-rouge">PayTable</code> subscriber to this message had to change how it handled the message.</p>

<p><a href="http://facebook.github.io/react/docs/addons.html">React Add-ons</a> (which it turns out is an awesome thing) has an update helper which is used to <a href="http://facebook.github.io/react/docs/update.html#shallow-merge">merge</a> the newly received filterBounds into the existing state.</p>

<pre><code class="language-JS">//the paytable now does
var newState = React.addons.update(this.state, {$merge: filterBounds});
</code></pre>

<p>Where previously the code replaced the state with the message body because we'd coupled everything up and implicitly the message body was known to match the state.</p>

<p>This <em>should</em> be better since, if I go on to fangle this much, it should handle change better as the <code class="language-plaintext highlighter-rouge">PayTable</code> makes fewer assumptions about the message payload.</p>

<h1 id="testing">Testing</h1>

<p>It was already getting to be a pain going to the site and changing values in the boxes to check that things were working the way I expectedâ€¦ which means we need tests!</p>

<p>Facebook have created Jest which is (I think) a wrapper around Jasmine. I tend to use Mochaâ€¦ and to be honest I didn't want to learn another new thing right now if I could avoid it. So I wondered if anyone else had solved the problem (and eventually realised they had.)</p>

<p>The steps I ended up taking were:</p>

<h1 id="1-install-mocha">1. Install Mocha</h1>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm <span class="nb">install</span> <span class="nt">--save-dev</span> mocha
npm <span class="nb">install</span> <span class="nt">--save-dev</span> gulp-mocha
npm <span class="nb">install</span> <span class="nt">--save-dev</span> should
</code></pre></div></div>

<h1 id="2-add-a-gulp-task-to-run-tests">2. Add a gulp task to run tests</h1>

<pre><code class="language-JS">gulp.task('test', function() {
    //this require line took me a while to figure out!
    //more below!
	require('./tests/compiler.js');
	return gulp.src(['tests/*Spec.js'], { read: false })
	.pipe(mocha({
		reporter: 'spec',
		globals: {
			should: require('should')
		}
	}));
});
</code></pre>

<p>If you don't Gulp this says grab all of the javascript files in the tests folder whose names end with Spec and pass them into Mocha.</p>

<h1 id="3-actually-have-some-tests">3. Actually have some tests</h1>

<p>I had to <code class="language-plaintext highlighter-rouge">npm install</code> <a href="https://github.com/tmpvar/jsdom">jsdom</a> since React has to have a DOM to work against. And then figure out (read largely copy from other people on the Google) how to have React render into that DOM. The secret-sauce was in the <a href="http://facebook.github.io/react/docs/test-utils.html">React.addons.TestUtils</a> which continues the React.addons reign of awesome.</p>

<p>The end result (snipped a little for clarity) was:</p>

<pre><code class="language-JS">'use strict';

var jsdom = require('jsdom');
var React = require('react/addons');
var postal = require('postal');
var bus = require('../app/scripts/messageBus');
var FilterBox = require('../app/scripts/filterBox');
var TestUtils = React.addons.TestUtils;

var handlerReceived;

before(function() {
	postal.subscribe({
		channel: bus.channels.filters,
		topic : bus.topics.filters.yearBoundsChange,
		callback: function(data) {
			handlerReceived = data;
		}
	});
});

describe('the filter box', function() {
	var filterBoxInputs;

	beforeEach(function() {
		handlerReceived = null;
		
		//fake a DOM for React to use
		global.document = jsdom.jsdom('&lt;!doctype html&gt;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;');
		global.window = document.parentWindow;

		var filterBox = TestUtils.renderIntoDocument(
			&lt;FilterBox initialEarliest={1990} initialLatest={2010}/&gt;
		);

		filterBoxInputs = TestUtils.scryRenderedDOMComponentsWithTag(filterBox, 'input');
	});

	describe('has a single earliest year input that', function() {
		var earliestInput;

		beforeEach(function() {
			var matchedInputs = filterBoxInputs.filter(function(element) {
				return element.props != undefined 
						&amp;&amp; element.props.name === 'Earliest';
			});
			matchedInputs.length.should.be.exactly(1);
			earliestInput = matchedInputs[0];
		});

		it('publishes an event when value changes', function() {
			TestUtils.Simulate.change(earliestInput, {target: {value: '1991'}});
			handlerReceived.should.match({earliest:1991});
		});

		it('sets initial earliest on render', function() {
			earliestInput.props.value.should.be.exactly(1990);
		});
	});

	describe('has a single latest year input that', function() {
		// ..snip
	});
});
</code></pre>

<p>So, only once, we subscribe to the message we're expecting our React component to publish and store the message body.</p>

<pre><code class="language-JS">var handlerReceived;

before(function() {
	postal.subscribe({
		channel: bus.channels.filters,
		topic : bus.topics.filters.yearBoundsChange,
		callback: function(data) {
			handlerReceived = data;
		}
	});
});
</code></pre>

<p>and then need to have a setup for each test:</p>

<pre><code class="language-JS">var filterBoxInputs;

beforeEach(function() {
	handlerReceived = null;
	
	//fake a DOM for React to use
	global.document = jsdom.jsdom('&lt;!doctype html&gt;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;');
	global.window = document.parentWindow;

	var filterBox = TestUtils.renderIntoDocument(
		&lt;FilterBox initialEarliest={1990} initialLatest={2010}/&gt;
	);

	filterBoxInputs = TestUtils.scryRenderedDOMComponentsWithTag(filterBox, 'input');
});
</code></pre>

<p>Here the handlerReceived is reset each time and then the global document and window variables that a browser would provide are setup.</p>

<p>TestUtils does the magic of rendering the component into that document. I guess it should be possible to compile the jsx to js and then use the actual <code class="language-plaintext highlighter-rouge">React.render</code> to put that into the document but that seems like a lot of work compared to <code class="language-plaintext highlighter-rouge">TestUtils.renderIntoDocument</code>.</p>

<p>Then a second use of <code class="language-plaintext highlighter-rouge">TestUtils</code>, with my first meeting of the word "scry" outside of fantasy novels, where <code class="language-plaintext highlighter-rouge">TestUtils.scryRenderedDOMComponentsWithTag</code> grabs input elements out of the rendered React component.</p>

<p>Well, no, it grabs any React components that shadow input controls. Not DOM elements as you might get from <code class="language-plaintext highlighter-rouge">document.getElementById</code> but the React equivalent.</p>

<p>For each input in the Filter box, as it stands, I want to run the same tests and since there are only two inputs right now I'm happy to stand that duplication until I need to remove it. So there are two describe blocks that are almost the same:</p>

<pre><code class="language-JS">describe('has a single earliest year input that', function() {
	var earliestInput;

	beforeEach(function() {
		var matchedInputs = filterBoxInputs.filter(function(element) {
			return element.props != undefined 
					&amp;&amp; element.props.name === 'Earliest';
		});
		matchedInputs.length.should.be.exactly(1);
		earliestInput = matchedInputs[0];
	});

	it('publishes an event when value changes', function() {
		TestUtils.Simulate.change(earliestInput, {target: {value: '1991'}});
		handlerReceived.should.match({earliest:1991});
	});

	it('sets initial earliest on render', function() {
		earliestInput.props.value.should.be.exactly(1990);
	});
});
</code></pre>

<p>In this block's <code class="language-plaintext highlighter-rouge">beforeEach</code> it grabs any input with the desired name, asserts there is only one, and stores that component so that it can be asserted against.</p>

<p>One test is straightforward and asserts that the default value matches expectation.</p>

<p>In the other test <code class="language-plaintext highlighter-rouge">TestUtils.Simulate.change</code> saves our bacon and handles the work of changing the value of the input box. A little bit magic-incantation-y but readable enough that I can live with it.</p>

<p>That change should have caused a message to be published and the test is subscribed to those messages so it can assert that the message body was received and matches expectation.</p>

<h1 id="but-but-mocha-can-jsx">Butâ€¦ Butâ€¦ Mocha can JSX?</h1>

<p>No, I found <a href="http://www.hammerlab.org/2015/02/14/testing-react-web-apps-with-mocha/">this blog post</a> which borrowed <a href="https://github.com/Khan/react-components/blob/7afcf35c921a2f984ddff71dead25217f8de3532/test/compiler.js">code from the Khan Academy</a> which can be passed to mocha as a compiler so that it can JSX when it needs toâ€¦</p>

<pre><code class="language-JS">var fs = require('fs'),
    ReactTools = require('react-tools'),
    origJs = require.extensions['.js'];

require.extensions['.js'] = function(module, filename) {
  // optimization: external code never needs compilation.
  if (filename.indexOf('node_modules/') &gt;= 0) {
    return (origJs || require.extensions['.js'])(module, filename);
  }
  var content = fs.readFileSync(filename, 'utf8');
  var compiled = ReactTools.transform(content, {harmony: true});
  return module._compile(compiled, filename);
};
</code></pre>

<p>This required the final NPM of the day adding in react-tools so that the JSX transformer was available.</p>

<p>And..</p>

<h1 id="ta-da">Ta-da</h1>

<p><img src="/images/tada.png" alt="passing tests" /></p>
:ET